#include <Adafruit_NeoPixel.h>

// ----------------------
// Photoresistor setup
// ----------------------
const int pr1 = A0;
const int pr2 = A1;
const int pr3 = A2;

// Hysteresis thresholds
const int thresholdHigh = 700;  // trigger when above
const int thresholdLow  = 650;  // reset when below

// Debounce timing (ms)
const unsigned long debounceTime = 400;

bool pr1Triggered = false;
bool pr2Triggered = false;
bool pr3Triggered = false;

unsigned long lastTrigger1 = 0;
unsigned long lastTrigger2 = 0;
unsigned long lastTrigger3 = 0;

// ----------------------
// NeoPixel setup
// ----------------------
Adafruit_NeoPixel pixel1(1, 3, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel pixel2(1, 4, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel pixel3(1, 5, NEO_GRB + NEO_KHZ800);

// Smooth rainbow variables
byte baseIndex = 0;              // shared base color index
unsigned long lastColorUpdate = 0;
const unsigned long colorInterval = 8; // ms between steps (smooth fade)

// Per-pixel phase offsets so they’re different colors
const byte offset1 = 0;
const byte offset2 = 85;         // about 120° around the wheel
const byte offset3 = 170;        // about 240° around the wheel

// Dim / dull level: 0 = full, 1,2,3 = progressively dimmer/duller
int dimLevel = 0;

// ----------------------
// Helper: update brightness based on dimLevel
// ----------------------
void updateBrightness() {
  int b = 255; // default full
  switch (dimLevel) {
    case 0: b = 255; break;                  // 100%
    case 1: b = 153; break;                  // ~60%
    case 2: b = 77;  break;                  // ~30%
    case 3: b = 26;  break;                  // ~10%
  }
  pixel1.setBrightness(b);
  pixel2.setBrightness(b);
  pixel3.setBrightness(b);
}

void setup() {
  Serial.begin(9600);

  // Neopixels
  pixel1.begin();
  pixel2.begin();
  pixel3.begin();

  updateBrightness();  // set initial brightness based on dimLevel (0)

  // Start with initial colors
  pixel1.setPixelColor(0, Wheel(baseIndex + offset1));
  pixel2.setPixelColor(0, Wheel(baseIndex + offset2));
  pixel3.setPixelColor(0, Wheel(baseIndex + offset3));

  pixel1.show();
  pixel2.show();
  pixel3.show();
}

void loop() {
  unsigned long now = millis();

  // -----------------------------------------
  // PHOTORESISTOR LOGIC with debounce + hysteresis
  // -----------------------------------------
  int val1 = analogRead(pr1);
  int val2 = analogRead(pr2);
  int val3 = analogRead(pr3);

  // PR1 -> send "1", set dimLevel = 1
  if (val1 > thresholdHigh && !pr1Triggered) {
    if (now - lastTrigger1 > debounceTime) {
      Serial.println("1");
      pr1Triggered = true;
      lastTrigger1 = now;

      dimLevel = 1;
      updateBrightness();
    }
  }
  if (val1 < thresholdLow && pr1Triggered) {
    pr1Triggered = false;
  }

  // PR2 -> send "2", set dimLevel = 2
  if (val2 > thresholdHigh && !pr2Triggered) {
    if (now - lastTrigger2 > debounceTime) {
      Serial.println("2");
      pr2Triggered = true;
      lastTrigger2 = now;

      dimLevel = 2;
      updateBrightness();
    }
  }
  if (val2 < thresholdLow && pr2Triggered) {
    pr2Triggered = false;
  }

  // PR3 -> send "3", set dimLevel = 3
  if (val3 > thresholdHigh && !pr3Triggered) {
    if (now - lastTrigger3 > debounceTime) {
      Serial.println("3");
      pr3Triggered = true;
      lastTrigger3 = now;

      dimLevel = 3;
      updateBrightness();
    }
  }
  if (val3 < thresholdLow && pr3Triggered) {
    pr3Triggered = false;
  }

  // -----------------------------------------
  // NEOPIXEL SMOOTH RAINBOW FADE, OFFSET PER PIXEL
  // -----------------------------------------
  if (now - lastColorUpdate >= colorInterval) {
    lastColorUpdate = now;

    baseIndex++;   // advance the base color smoothly (byte wraps 0–255 automatically)

    uint32_t c1 = Wheel(baseIndex + offset1);
    uint32_t c2 = Wheel(baseIndex + offset2);
    uint32_t c3 = Wheel(baseIndex + offset3);

    pixel1.setPixelColor(0, c1);
    pixel2.setPixelColor(0, c2);
    pixel3.setPixelColor(0, c3);

    pixel1.show();
    pixel2.show();
    pixel3.show();
  }
}

// -----------------------------------------
// Rainbow color helper with "dullness"
// -----------------------------------------
uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
  byte r, g, b;

  if (WheelPos < 85) {
    r = 255 - WheelPos * 3;
    g = 0;
    b = WheelPos * 3;
  } else if (WheelPos < 170) {
    WheelPos -= 85;
    r = 0;
    g = WheelPos * 3;
    b = 255 - WheelPos * 3;
  } else {
    WheelPos -= 170;
    r = WheelPos * 3;
    g = 255 - WheelPos * 3;
    b = 0;
  }

  // Dull levels: mix towards gray
  int k = 0; // 0 = vivid, higher = duller (0–100)
  switch (dimLevel) {
    case 0: k = 0;  break;  // full color
    case 1: k = 30; break;  // a bit duller
    case 2: k = 65; break;  // quite dull
    case 3: k = 85; break;  // very dull
  }

  if (k > 0) {
    byte gray = (r + g + b) / 3;
    // integer mix: new = (orig*(100-k) + gray*k) / 100
    r = (byte)((r * (100 - k) + gray * k) / 100);
    g = (byte)((g * (100 - k) + gray * k) / 100);
    b = (byte)((b * (100 - k) + gray * k) / 100);
  }

  return pixel1.Color(r, g, b);
}
